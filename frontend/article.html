<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#e8758f">
    <title>ÊñáÁ´†ËØ¶ÊÉÖ</title>
    <script type="importmap">
        {
            "imports": {
                "playcanvas": "https://esm.run/playcanvas@2.5.0"
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .article-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: white;
            display: flex;
            align-items: center;
            padding: 0 12px;
            z-index: 1000;
            border-bottom: 1px solid #eee;
            padding-top: env(safe-area-inset-top);
            height: calc(50px + env(safe-area-inset-top));
        }
        .back-btn {
            width: 40px;
            height: 40px;
            background: none;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            cursor: pointer;
        }
        .header-title {
            flex: 1;
            text-align: center;
            font-size: 17px;
            font-weight: 500;
            color: #333;
            margin-right: 40px;
        }
        .article-frame {
            position: fixed;
            top: 50px;
            top: calc(50px + env(safe-area-inset-top));
            left: 0;
            right: 0;
            bottom: 0;
            border: none;
            width: 100%;
            height: calc(100% - 50px - env(safe-area-inset-top));
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-size: 14px;
        }
        
        /* È´òÊñØÊ®°ÂûãÂÆπÂô®Ê†∑Âºè - Ëá™ÈÄÇÂ∫îcanvasÂÜÖÂÆπ */
        .splat-container {
            position: relative;
            width: 100%;
            background: #0d0d1a;
            border-radius: 16px;
            overflow: hidden;
            margin: 16px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .gsplat-canvas {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            display: block;
        }
        
        .gsplat-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #e91e63;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
        }
        
        .loading-progress {
            margin-top: 8px;
            font-size: 12px;
            color: #e91e63;
        }
    </style>
</head>
<body>
    <header class="article-header">
        <button class="back-btn" onclick="history.back()" aria-label="ËøîÂõû">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
        <div class="header-title">ÊñáÁ´†ËØ¶ÊÉÖ</div>
    </header>
    
    <div class="loading" id="loading">Âä†ËΩΩ‰∏≠...</div>
    
    <iframe class="article-frame" id="articleFrame" onload="document.getElementById('loading').style.display='none'"></iframe>
    
    <script type="module">
        console.log('üöÄ Article.html ËÑöÊú¨ÂºÄÂßãÊâßË°å');
        
        // ÂÖ®Â±ÄÈîôËØØÊçïËé∑
        window.addEventListener('error', (e) => {
            console.error('‚ùå ÂÖ®Â±ÄÈîôËØØ:', e.message, e.filename, e.lineno);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('‚ùå Êú™Â§ÑÁêÜÁöÑPromiseÊãíÁªù:', e.reason);
        });
        
        import * as pc from 'playcanvas';
        
        // Ê£ÄÊü•WebGL2ÊîØÊåÅ
        function supportsWebGL2() {
            try {
                const canvas = document.createElement('canvas');
                return !!(canvas.getContext('webgl2'));
            } catch (e) {
                return false;
            }
        }
        
        const isWebGL2Supported = supportsWebGL2();
        console.log('WebGL2ÊîØÊåÅ:', isWebGL2Supported);
        
        // ÈôÄËû∫‰ª™Áõ∏ÂÖ≥ÂèòÈáè
        let gyroPermissionGranted = false;
        let gyroListenerAdded = false;
        let initialGyro = null;
        
        // ËØ∑Ê±ÇÈôÄËû∫‰ª™ÊùÉÈôêÔºàÂ§çÂàªgsplat-viewer2.htmlÔºâ
        async function requestGyroPermission() {
            if (!window.DeviceOrientationEvent) {
                console.log('ËÆæÂ§á‰∏çÊîØÊåÅÈôÄËû∫‰ª™');
                return false;
            }

            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    console.log('ËØ∑Ê±Ç iOS ÈôÄËû∫‰ª™ÊùÉÈôê...');
                    const permission = await DeviceOrientationEvent.requestPermission();
                    console.log('ÈôÄËû∫‰ª™ÊùÉÈôêÁªìÊûú:', permission);
                    if (permission !== 'granted') {
                        console.log('ÈôÄËû∫‰ª™ÊùÉÈôêË¢´ÊãíÁªù');
                        return false;
                    }
                    gyroPermissionGranted = true;
                } catch (error) {
                    console.error('ËØ∑Ê±ÇÈôÄËû∫‰ª™ÊùÉÈôêÂ§±Ë¥•:', error);
                    return false;
                }
            } else {
                gyroPermissionGranted = true;
            }

            console.log('ÈôÄËû∫‰ª™ÂàùÂßãÂåñÊàêÂäü');
            return true;
        }
        
        // ÂàõÂª∫PlayCanvasÂ∫îÁî®Âπ∂Âä†ËΩΩÈ´òÊñØÊ®°ÂûãÔºàÂÆåÂÖ®Â§çÂàªgsplat-viewer2.htmlÔºâ
        async function createGSplatViewer(container, plyName) {
            const canvas = container.querySelector('.gsplat-canvas');
            const loadingEl = container.querySelector('.gsplat-loading');
            
            try {
                // ÂàõÂª∫ÂõæÂΩ¢ËÆæÂ§á
                const device = await pc.createGraphicsDevice(canvas, {
                    deviceTypes: ['webgl2'],  // Âè™‰ΩøÁî®WebGL2
                    antialias: false
                });
                device.maxPixelRatio = Math.min(window.devicePixelRatio, 2);
                
                // ÂàõÂª∫Â∫îÁî®
                const createOptions = new pc.AppOptions();
                createOptions.graphicsDevice = device;
                createOptions.componentSystems = [
                    pc.RenderComponentSystem,
                    pc.CameraComponentSystem,
                    pc.LightComponentSystem,
                    pc.GSplatComponentSystem
                ];
                createOptions.resourceHandlers = [
                    pc.TextureHandler,
                    pc.ContainerHandler,
                    pc.GSplatHandler
                ];
                
                const app = new pc.AppBase(canvas);
                app.init(createOptions);
                app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
                app.setCanvasResolution(pc.RESOLUTION_AUTO);
                
                // Âº∫Âà∂canvas‰ΩøÁî®16:9ÊØî‰æã - ‰øÆÊ≠£PlayCanvasÁöÑÂ∞∫ÂØ∏ËÆæÁΩÆ
                const resizeCanvas = () => {
                    const containerWidth = container.clientWidth;
                    const targetHeight = Math.round(containerWidth * 9 / 16);
                    canvas.style.width = containerWidth + 'px';
                    canvas.style.height = targetHeight + 'px';
                    canvas.width = containerWidth * window.devicePixelRatio;
                    canvas.height = targetHeight * window.devicePixelRatio;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // ÂàõÂª∫Áõ∏Êú∫ - ‰ΩøÁî®gsplat-viewer2.htmlÁöÑÈÖçÁΩÆ
                const camera = new pc.Entity('camera');
                camera.addComponent('camera', {
                    clearColor: new pc.Color(0.05, 0.05, 0.1),
                    fov: 35,
                    horizontalFov: false,
                    nearClip: 0.1,
                    farClip: 1000
                });
                camera.setLocalPosition(0, 0, 0.0);  // ‰∏égsplat-viewer2.html‰øùÊåÅ‰∏ÄËá¥
                camera.lookAt(0, 0, 0);
                app.root.addChild(camera);
                
                // ÂàõÂª∫ÂÖâÊ∫ê
                const light = new pc.Entity('light');
                light.addComponent('light', {
                    type: 'directional',
                    color: new pc.Color(1, 1, 1),
                    intensity: 1
                });
                light.setLocalEulerAngles(45, 30, 0);
                app.root.addChild(light);
                
                // ÂêØÂä®Â∫îÁî®
                app.start();
                
                // Âä†ËΩΩPLYÊ®°Âûã
                const url = `/data/ply/${plyName}.ply`;
                const asset = new pc.Asset(plyName, 'gsplat', { url: url });
                
                await new Promise((resolve, reject) => {
                    asset.on('load', resolve);
                    asset.on('error', reject);
                    app.assets.add(asset);
                    app.assets.load(asset);
                });
                
                // Êõ¥Êñ∞Âä†ËΩΩÊèêÁ§∫
                if (loadingEl) {
                    loadingEl.innerHTML = `
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Ê∏≤Êüì3DÊ®°Âûã...</div>
                    `;
                }
                
                // ÂàõÂª∫È´òÊñØÊ≥ºÊ∫ÖÂÆû‰Ωì
                const splatEntity = new pc.Entity('gsplat');
                splatEntity.addComponent('gsplat', { asset: asset });
                splatEntity.setLocalEulerAngles(180, 0, 0); // ÈªòËÆ§ÁøªËΩ¨
                app.root.addChild(splatEntity);
                
                // Ê®°ÂûãÊéßÂà∂ÂèòÈáè
                let modelPosition = { x: 0, y: 0, z: 0 };
                let targetModelPosition = { x: 0, y: 0, z: 0 };
                let modelRotation = { x: 180, y: 0, z: 0 };
                let targetModelRotation = { x: 180, y: 0, z: 0 };
                let initialGyro = null;
                let scrollYOffset = 0;
                
                const config = {
                    parallaxIntensity: 0.3,
                    gyroEnabled: true
                };
                
                // Êõ¥Êñ∞Âæ™ÁéØ
                app.on('update', (dt) => {
                    const smoothFactor = 0.1;
                    
                    modelPosition.x += (targetModelPosition.x - modelPosition.x) * smoothFactor;
                    const finalTargetY = targetModelPosition.y + scrollYOffset;
                    modelPosition.y += (finalTargetY - modelPosition.y) * smoothFactor;
                    modelPosition.z += (targetModelPosition.z - modelPosition.z) * smoothFactor;
                    
                    modelRotation.x += (targetModelRotation.x - modelRotation.x) * smoothFactor;
                    modelRotation.y += (targetModelRotation.y - modelRotation.y) * smoothFactor;
                    modelRotation.z += (targetModelRotation.z - modelRotation.z) * smoothFactor;
                    
                    splatEntity.setLocalPosition(modelPosition.x, modelPosition.y, modelPosition.z);
                    splatEntity.setLocalEulerAngles(modelRotation.x, modelRotation.y, modelRotation.z);
                });
                
                // ease-outË°∞ÂáèÊõ≤Á∫ø
                function easeOutCubic(value, threshold, max) {
                    const absValue = Math.abs(value);
                    if (absValue <= threshold) return value;
                    const sign = value >= 0 ? 1 : -1;
                    const normalized = (absValue - threshold) / (max - threshold);
                    const damped = threshold + (max - threshold) * (1 - Math.pow(1 - normalized, 3));
                    return sign * Math.min(damped, max);
                }
                
                // Èº†Ê†áÊéßÂà∂
                let isDragging = false;
                let lastX = 0, lastY = 0;
                
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => isDragging = false);
                canvas.addEventListener('mouseleave', () => isDragging = false);
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) {
                        const rect = canvas.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const normalizedX = (e.clientX - centerX) / (rect.width / 2);
                        const normalizedY = (e.clientY - centerY) / (rect.height / 2);
                        
                        const simulatedGamma = normalizedX * 35;
                        const simulatedBeta = normalizedY * 25;
                        const dampenedBeta = easeOutCubic(simulatedBeta, 15, 25) * 0.5;
                        const dampenedGamma = easeOutCubic(simulatedGamma, 20, 35);
                        
                        targetModelRotation.x = 180 + dampenedBeta * config.parallaxIntensity;
                        targetModelRotation.y = -dampenedGamma * config.parallaxIntensity;
                        
                        const positionIntensity = 0.008;
                        targetModelPosition.x = -dampenedGamma * positionIntensity;
                        targetModelPosition.y = dampenedBeta * positionIntensity * 0.5;
                    } else {
                        const deltaX = e.clientX - lastX;
                        const deltaY = e.clientY - lastY;
                        targetModelRotation.y += deltaX * 0.5;
                        targetModelRotation.x += deltaY * 0.5;
                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });
                
                // ÈôÄËû∫‰ª™ÊéßÂà∂
                if (window.DeviceOrientationEvent) {
                    const handleOrientation = (e) => {
                        if (!config.gyroEnabled || e.beta === null || e.gamma === null) return;
                        
                        if (!initialGyro) {
                            initialGyro = { beta: e.beta, gamma: e.gamma };
                            return;
                        }
                        
                        const deltaBeta = e.beta - initialGyro.beta;
                        const deltaGamma = e.gamma - initialGyro.gamma;
                        
                        const dampenedBeta = easeOutCubic(deltaBeta, 15, 25) * 0.5;
                        const dampenedGamma = easeOutCubic(deltaGamma, 20, 35);
                        
                        targetModelRotation.x = 180 + dampenedBeta * config.parallaxIntensity;
                        targetModelRotation.y = -dampenedGamma * config.parallaxIntensity;
                        
                        const positionIntensity = 0.008;
                        targetModelPosition.x = -dampenedGamma * positionIntensity;
                        targetModelPosition.y = dampenedBeta * positionIntensity * 0.5;
                    };
                    
                    // Ê∑ªÂä†ÈôÄËû∫‰ª™ÁõëÂê¨Âô®
                    if (!gyroListenerAdded) {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        gyroListenerAdded = true;
                        console.log('‚úÖ ÈôÄËû∫‰ª™‰∫ã‰ª∂ÁõëÂê¨Â∑≤Ê∑ªÂä†');
                    }
                }
                
                // ÊªöÂä®ËßÜÂ∑Æ - ÁõëÂê¨iframeÂÜÖÈÉ®ÊªöÂä®
                function getElementViewportPosition(element) {
                    const rect = element.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    const elementCenter = rect.top + rect.height / 2;
                    const viewportCenter = viewportHeight / 2;
                    const normalizedPosition = (elementCenter - viewportCenter) / (viewportHeight / 2);
                    return Math.max(-1, Math.min(1, normalizedPosition));
                }
                
                function easeOutCubicPosition(value, threshold, max) {
                    const absValue = Math.abs(value);
                    if (absValue <= threshold) return value;
                    const sign = value >= 0 ? 1 : -1;
                    const normalized = (absValue - threshold) / (max - threshold);
                    const damped = threshold + (max - threshold) * (1 - Math.pow(1 - normalized, 3));
                    return sign * Math.min(damped, max);
                }
                
                let initialScrollOffset = null;
                
                function updateScrollParallax() {
                    const position = getElementViewportPosition(container);
                    if (initialScrollOffset === null) {
                        initialScrollOffset = position;
                    }
                    const rawOffset = position - initialScrollOffset;
                    const dampenedOffset = easeOutCubicPosition(rawOffset, 0.6, 1.0);
                    const maxYOffset = 0.5 * 0.6;
                    scrollYOffset = -dampenedOffset * maxYOffset;
                }
                
                // ÁõëÂê¨iframeÂÜÖÈÉ®ÊªöÂä®
                try {
                    const iframeWin = document.getElementById('articleFrame').contentWindow;
                    if (iframeWin) {
                        iframeWin.addEventListener('scroll', updateScrollParallax, { passive: true });
                    }
                } catch (e) {
                    // ÂøΩÁï•Ë∑®ÂüüÈîôËØØ
                }
                window.addEventListener('scroll', updateScrollParallax, { passive: true });
                updateScrollParallax();
                
                // ÈôÄËû∫‰ª™ÊéßÂà∂ÔºàÂ§çÂàªgsplat-viewer2.htmlÔºâ
                if (gyroPermissionGranted && !gyroListenerAdded) {
                    window.addEventListener('deviceorientation', (event) => {
                        if (!config.gyroEnabled) return;
                        
                        if (!initialGyro) {
                            initialGyro = { beta: event.beta || 0, gamma: event.gamma || 0 };
                        }
                        
                        const deltaX = (event.gamma || 0) - initialGyro.gamma;
                        const deltaY = (event.beta || 0) - initialGyro.beta;
                        
                        const maxRotation = 15;
                        const dampedX = easeOutCubic(deltaX, 10, 30);
                        const dampedY = easeOutCubic(deltaY, 10, 30);
                        
                        targetModelRotation.y = pc.math.clamp(-dampedX * 1.5, -maxRotation, maxRotation);
                        targetModelRotation.x = 180 + pc.math.clamp(dampedY * 1.5, -maxRotation, maxRotation);
                    });
                    gyroListenerAdded = true;
                }
                
                // ÊàêÂäü! ÈöêËóèÂä†ËΩΩÊèêÁ§∫
                if (loadingEl) loadingEl.style.display = 'none';
                console.log('‚úì 3DÊ®°ÂûãÂä†ËΩΩÊàêÂäü:', plyName);
                
                return true;
                
            } catch (error) {
                console.error('‚úó 3DÊ®°ÂûãÂä†ËΩΩÂ§±Ë¥•:', plyName, error);
                if (loadingEl) loadingEl.textContent = 'Âä†ËΩΩÂ§±Ë¥•';
                return false;
            }
        }
        
        // ÊñáÁ´†IDÂà∞mirrorsÁõÆÂΩïÁöÑÊò†Â∞Ñ
        const articleMap = {
            1: '01',   // ËÖæËÆØÊñ∞Èóª
            2: '02',   // Ê∑±Â∫¶‰∏®‰∏âËà™ÊØçÊó∂‰ª£
            3: '03',   // Ê∑±Âú≥ÈùíÂπ¥‰ΩèÊàø
            4: '04',   // Êµ∑ÂçóËá™Ë¥∏Ê∏Ø
            5: '05',   // Â§ñ‰∫§ÈÉ®‰∫öÊ¥≤Áâπ‰Ωø
            6: '06',   // ÂÖÉÊó¶ÁÅ´ËΩ¶Á•®
            7: '07',   // ÂíèÊò•ËàûÂâß
            8: '08',   // È£üÁâ©Èì∂Ë°å
            9: '12',   // ÊúüÂæÖÔºÅÊ∑±Âú≥Â•áËøπ
            10: '09',  // ‰∏≠Â§ÆË¥¢Âäû
            11: '10',  // Â±±‰∏úËà∞ÂÖ•Âàó6Âë®Âπ¥
            12: '11'   // Âè∞ÂΩìÂ±ÄÂ∞èÁ∫¢‰π¶
        };
        
        // Ëé∑ÂèñÂΩìÂâçÊñáÁ´†ID
        const urlParams = new URLSearchParams(window.location.search);
        const articleId = urlParams.get('id') || '1';
        const mirrorDir = articleMap[articleId] || '01';
        
        console.log(`üìñ Âä†ËΩΩÊñáÁ´†ID: ${articleId} -> mirrors/${mirrorDir}`);
        
        // Ëé∑ÂèñiframeÂÖÉÁ¥†
        const iframe = document.getElementById('articleFrame');
        
        if (!iframe) {
            console.error('‚ùå Êâæ‰∏çÂà∞iframeÂÖÉÁ¥†');
        }
        
        // ÂÖàËÆæÁΩÆload‰∫ã‰ª∂ÁõëÂê¨Âô®
        iframe.addEventListener('load', async () => {
            console.log('üìÑ IframeÂä†ËΩΩÂÆåÊàê');
            
            // ËØ∑Ê±ÇÈôÄËû∫‰ª™ÊùÉÈôêÔºàÈ¶ñÊ¨°‰∫§‰∫íÊó∂Ôºâ
            const requestPermissionOnInteraction = async () => {
                await requestGyroPermission();
                document.removeEventListener('touchstart', requestPermissionOnInteraction);
                document.removeEventListener('click', requestPermissionOnInteraction);
            };
            document.addEventListener('touchstart', requestPermissionOnInteraction, { once: true });
            document.addEventListener('click', requestPermissionOnInteraction, { once: true });
            
            // Á≠âÂæÖiframeÂÆåÂÖ®Ê∏≤Êüì
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                if (!iframeDoc) {
                    console.error('‚ùå Êó†Ê≥ïËÆøÈóÆiframeÂÜÖÂÆπÔºàÂèØËÉΩÊòØË∑®ÂüüÈóÆÈ¢òÔºâ');
                    return;
                }
                
                console.log('üîç iframe src:', iframe.src);
                console.log('üîç iframe contentWindow.location:', iframe.contentWindow.location.href);
                console.log('üîç iframe DOM ready state:', iframeDoc.readyState);
                console.log('üîç iframe body:', iframeDoc.body ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
                console.log('üîç iframe HTML length:', iframeDoc.documentElement.outerHTML.length);
                
                // ËæìÂá∫HTMLÁöÑÂâç1000‰∏™Â≠óÁ¨¶Áî®‰∫éË∞ÉËØï
                const htmlPreview = iframeDoc.documentElement.outerHTML.substring(0, 1000);
                console.log('üîç iframe HTML preview (Ââç1000Â≠óÁ¨¶):\n', htmlPreview);
                
                // ÂÖàÊü•ÊâæÊâÄÊúâdiv
                const allDivs = iframeDoc.querySelectorAll('div');
                console.log('üîç ÊâÄÊúâdivÊï∞Èáè:', allDivs.length);
                
                // Êü•ÊâæÂ∏¶classÁöÑdiv
                const divsWithClass = iframeDoc.querySelectorAll('div[class]');
                console.log('üîç Â∏¶classÁöÑdivÊï∞Èáè:', divsWithClass.length);
                
                // Êü•ÊâæÊâÄÊúâÂ∏¶data-plyÁöÑÂÖÉÁ¥†
                const allDataPly = iframeDoc.querySelectorAll('[data-ply]');
                console.log('üîç Â∏¶data-plyÁöÑÂÖÉÁ¥†:', allDataPly.length);
                
                // Áõ¥Êé•ÊêúÁ¥¢HTML‰∏≠ÊòØÂê¶ÂåÖÂê´splat-container
                const htmlContent = iframeDoc.documentElement.outerHTML;
                const hasSplatContainer = htmlContent.includes('splat-container');
                console.log('üîç HTML‰∏≠ÂåÖÂê´splat-container:', hasSplatContainer);
                
                if (hasSplatContainer) {
                    console.log('üîç Â∞ùËØïÁî®‰∏çÂêåÈÄâÊã©Âô®Êü•Êâæ...');
                    const test1 = iframeDoc.querySelector('.splat-container');
                    const test2 = iframeDoc.querySelector('div.splat-container');
                    const test3 = iframeDoc.querySelectorAll('.splat-container');
                    console.log('querySelector(.splat-container):', test1);
                    console.log('querySelector(div.splat-container):', test2);
                    console.log('querySelectorAll(.splat-container):', test3);
                }
                
                // Êü•ÊâæÊâÄÊúâÂ∏¶ data-ply Â±ûÊÄßÁöÑÂÆπÂô®
                const gsplatContainers = iframeDoc.querySelectorAll('.splat-container[data-ply]');
                
                console.log('üîç querySelectorAllÁªìÊûú:', gsplatContainers);
                console.log('üîç ÊâæÂà∞ÁöÑÂÆπÂô®Êï∞Èáè:', gsplatContainers.length);
                
                if (gsplatContainers.length === 0) {
                    console.log('‚ÑπÔ∏è ÂΩìÂâçÊñáÁ´†Ê≤°Êúâ3DÊ®°Âûã');
                    return;
                }
                
                console.log(`üéØ ÊâæÂà∞ ${gsplatContainers.length} ‰∏™3DÊ®°ÂûãÂÆπÂô®`);
                
                // ‰ΩøÁî® Intersection Observer ÂÆûÁé∞Âª∂ËøüÂä†ËΩΩÔºåÂáèÂ∞ëÂÜÖÂ≠òÂéãÂäõ
                const loadedModels = new Set();
                
                const observerOptions = {
                    root: null,
                    rootMargin: '300px',  // ÊèêÂâç300pxÂºÄÂßãÂä†ËΩΩ
                    threshold: 0.01
                };
                
                const modelObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const container = entry.target;
                            const plyName = container.getAttribute('data-ply');
                            
                            if (!loadedModels.has(plyName)) {
                                loadedModels.add(plyName);
                                const index = Array.from(gsplatContainers).indexOf(container);
                                console.log(`üëÅÔ∏è [${index + 1}/${gsplatContainers.length}] Ê®°ÂûãËøõÂÖ•ËßÜÂè£,ÂºÄÂßãÂä†ËΩΩ: ${plyName}`);
                                
                                createGSplatViewer(container, plyName).catch(err => {
                                    console.error(`‚ùå Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥• [${plyName}]:`, err);
                                    loadedModels.delete(plyName);  // Â§±Ë¥•ÂêéÂÖÅËÆ∏ÈáçËØï
                                });
                                
                                // Âä†ËΩΩÂêéÂÅúÊ≠¢ËßÇÂØüÊ≠§ÂÆπÂô®
                                modelObserver.unobserve(container);
                            }
                        }
                    });
                }, observerOptions);
                
                // ËßÇÂØüÊâÄÊúâÂÆπÂô®
                gsplatContainers.forEach((container) => {
                    modelObserver.observe(container);
                });
                
            } catch (error) {
                console.error('‚ùå iframeÂàùÂßãÂåñÈîôËØØ:', error);
            }
        });
        
        // ÊúÄÂêéÂä†ËΩΩiframeÂÜÖÂÆπ - Ê∑ªÂä†Êó∂Èó¥Êà≥ÁªïËøáSafariÁºìÂ≠ò
        iframe.src = '/mirrors/' + mirrorDir + '/index.html?t=' + Date.now();
    </script>
</body>
</html>
