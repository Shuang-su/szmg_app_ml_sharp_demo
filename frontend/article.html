<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#e8758f">
    <title>æ–‡ç« è¯¦æƒ…</title>
    <script type="importmap">
        {
            "imports": {
                "playcanvas": "https://esm.run/playcanvas@2.5.0"
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .article-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: white;
            display: flex;
            align-items: center;
            padding: 0 12px;
            z-index: 1000;
            border-bottom: 1px solid #eee;
            padding-top: env(safe-area-inset-top);
            height: calc(50px + env(safe-area-inset-top));
        }
        .back-btn {
            width: 40px;
            height: 40px;
            background: none;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            cursor: pointer;
        }
        .header-title {
            flex: 1;
            text-align: center;
            font-size: 17px;
            font-weight: 500;
            color: #333;
            margin-right: 40px;
        }
        .article-frame {
            position: fixed;
            top: 50px;
            top: calc(50px + env(safe-area-inset-top));
            left: 0;
            right: 0;
            bottom: 0;
            border: none;
            width: 100%;
            height: calc(100% - 50px - env(safe-area-inset-top));
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-size: 14px;
        }
        
        /* é«˜æ–¯æ¨¡å‹å®¹å™¨æ ·å¼ - è‡ªé€‚åº”canvaså†…å®¹ */
        .splat-container {
            position: relative;
            width: 100%;
            background: #0d0d1a;
            border-radius: 16px;
            overflow: hidden;
            margin: 16px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .gsplat-canvas {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            display: block;
        }
        
        .gsplat-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #e91e63;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
        }
        
        .loading-progress {
            margin-top: 8px;
            font-size: 12px;
            color: #e91e63;
        }
    </style>
</head>
<body>
    <header class="article-header">
        <button class="back-btn" onclick="history.back()" aria-label="è¿”å›">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
        <div class="header-title">æ–‡ç« è¯¦æƒ…</div>
    </header>
    
    <div class="loading" id="loading">åŠ è½½ä¸­...</div>
    
    <iframe class="article-frame" id="articleFrame" onload="document.getElementById('loading').style.display='none'"></iframe>
    
    <script type="module">
        console.log('ğŸš€ Article.html è„šæœ¬å¼€å§‹æ‰§è¡Œ');
        
        // å…¨å±€é”™è¯¯æ•è·
        window.addEventListener('error', (e) => {
            console.error('âŒ å…¨å±€é”™è¯¯:', e.message, e.filename, e.lineno);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('âŒ æœªå¤„ç†çš„Promiseæ‹’ç»:', e.reason);
        });
        
        import * as pc from 'playcanvas';
        
        // æ£€æŸ¥WebGL2æ”¯æŒ
        function supportsWebGL2() {
            try {
                const canvas = document.createElement('canvas');
                return !!(canvas.getContext('webgl2'));
            } catch (e) {
                return false;
            }
        }
        
        const isWebGL2Supported = supportsWebGL2();
        console.log('WebGL2æ”¯æŒ:', isWebGL2Supported);
        
        // é™€èºä»ªç›¸å…³å˜é‡
        let gyroPermissionGranted = false;
        let gyroListenerAdded = false;
        let initialGyro = null;
        
        // è¯·æ±‚é™€èºä»ªæƒé™ï¼ˆiOSéœ€è¦å¼¹çª—ï¼‰
        async function requestGyroPermission() {
            if (!window.DeviceOrientationEvent) {
                console.log('è®¾å¤‡ä¸æ”¯æŒé™€èºä»ª');
                return false;
            }

            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    console.log('è¯·æ±‚ iOS é™€èºä»ªæƒé™...');
                    const permission = await DeviceOrientationEvent.requestPermission();
                    console.log('é™€èºä»ªæƒé™ç»“æœ:', permission);
                    if (permission !== 'granted') {
                        console.log('é™€èºä»ªæƒé™è¢«æ‹’ç»');
                        return false;
                    }
                    gyroPermissionGranted = true;
                } catch (error) {
                    console.error('è¯·æ±‚é™€èºä»ªæƒé™å¤±è´¥:', error);
                    return false;
                }
            } else {
                gyroPermissionGranted = true;
            }

            console.log('é™€èºä»ªåˆå§‹åŒ–æˆåŠŸ');
            return true;
        }
        
        // æ˜¾ç¤ºé™€èºä»ªæƒé™è¯·æ±‚å¼¹çª—
        function showGyroPermissionModal() {
            if (typeof DeviceOrientationEvent === 'undefined' || 
                typeof DeviceOrientationEvent.requestPermission !== 'function') {
                return; // éiOSè®¾å¤‡ä¸éœ€è¦å¼¹çª—
            }
            
            const overlay = document.createElement('div');
            overlay.id = 'gyro-permission-overlay';
            overlay.innerHTML = `
                <div class="gyro-permission-modal">
                    <div class="gyro-icon">ğŸ“±</div>
                    <h3>å¯ç”¨3Dè§†å·®æ•ˆæœ</h3>
                    <p>å…è®¸è®¿é—®è®¾å¤‡é™€èºä»ªï¼Œé€šè¿‡å€¾æ–œæ‰‹æœºä½“éªŒæ²‰æµ¸å¼3Dæ•ˆæœ</p>
                    <button id="gyro-enable-btn">å¯ç”¨</button>
                    <button id="gyro-skip-btn">è·³è¿‡</button>
                </div>
            `;
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                animation: fadeIn 0.3s ease-out;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                .gyro-permission-modal {
                    background: white;
                    border-radius: 16px;
                    padding: 32px 24px;
                    text-align: center;
                    max-width: 300px;
                    margin: 20px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                }
                .gyro-permission-modal .gyro-icon {
                    font-size: 48px;
                    margin-bottom: 16px;
                }
                .gyro-permission-modal h3 {
                    margin: 0 0 12px 0;
                    font-size: 18px;
                    color: #222;
                }
                .gyro-permission-modal p {
                    margin: 0 0 24px 0;
                    font-size: 14px;
                    color: #666;
                    line-height: 1.5;
                }
                .gyro-permission-modal button {
                    width: 100%;
                    padding: 14px;
                    border: none;
                    border-radius: 10px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    margin-bottom: 10px;
                    transition: transform 0.1s;
                }
                .gyro-permission-modal button:active {
                    transform: scale(0.98);
                }
                #gyro-enable-btn {
                    background: linear-gradient(135deg, #ff4081, #ff79b0);
                    color: white;
                }
                #gyro-skip-btn {
                    background: #f5f5f5;
                    color: #666;
                    margin-bottom: 0;
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(overlay);
            
            document.getElementById('gyro-enable-btn').addEventListener('click', async () => {
                await requestGyroPermission();
                overlay.remove();
            });
            
            document.getElementById('gyro-skip-btn').addEventListener('click', () => {
                overlay.remove();
            });
        }
        
        // åˆ›å»ºPlayCanvasåº”ç”¨å¹¶åŠ è½½é«˜æ–¯æ¨¡å‹ï¼ˆå®Œå…¨å¤åˆ»gsplat-viewer2.htmlï¼‰
        async function createGSplatViewer(container, plyName) {
            const canvas = container.querySelector('.gsplat-canvas');
            const loadingEl = container.querySelector('.gsplat-loading');
            
            try {
                // åˆ›å»ºå›¾å½¢è®¾å¤‡
                const device = await pc.createGraphicsDevice(canvas, {
                    deviceTypes: ['webgl2'],  // åªä½¿ç”¨WebGL2
                    antialias: false
                });
                device.maxPixelRatio = Math.min(window.devicePixelRatio, 2);
                
                // åˆ›å»ºåº”ç”¨
                const createOptions = new pc.AppOptions();
                createOptions.graphicsDevice = device;
                createOptions.componentSystems = [
                    pc.RenderComponentSystem,
                    pc.CameraComponentSystem,
                    pc.LightComponentSystem,
                    pc.GSplatComponentSystem
                ];
                createOptions.resourceHandlers = [
                    pc.TextureHandler,
                    pc.ContainerHandler,
                    pc.GSplatHandler
                ];
                
                const app = new pc.AppBase(canvas);
                app.init(createOptions);
                app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
                app.setCanvasResolution(pc.RESOLUTION_AUTO);
                
                // å¼ºåˆ¶canvasä½¿ç”¨16:9æ¯”ä¾‹ - ä¿®æ­£PlayCanvasçš„å°ºå¯¸è®¾ç½®
                const resizeCanvas = () => {
                    const containerWidth = container.clientWidth;
                    const targetHeight = Math.round(containerWidth * 9 / 16);
                    canvas.style.width = containerWidth + 'px';
                    canvas.style.height = targetHeight + 'px';
                    canvas.width = containerWidth * window.devicePixelRatio;
                    canvas.height = targetHeight * window.devicePixelRatio;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // åˆ›å»ºç›¸æœº - ä½¿ç”¨gsplat-viewer2.htmlçš„é…ç½®
                const camera = new pc.Entity('camera');
                camera.addComponent('camera', {
                    clearColor: new pc.Color(0.05, 0.05, 0.1),
                    fov: 35,
                    horizontalFov: false,
                    nearClip: 0.1,
                    farClip: 1000
                });
                camera.setLocalPosition(0, 0, 0.0);  // ä¸gsplat-viewer2.htmlä¿æŒä¸€è‡´
                camera.lookAt(0, 0, 0);
                app.root.addChild(camera);
                
                // åˆ›å»ºå…‰æº
                const light = new pc.Entity('light');
                light.addComponent('light', {
                    type: 'directional',
                    color: new pc.Color(1, 1, 1),
                    intensity: 1
                });
                light.setLocalEulerAngles(45, 30, 0);
                app.root.addChild(light);
                
                // å¯åŠ¨åº”ç”¨
                app.start();
                
                // åŠ è½½PLYæ¨¡å‹
                const url = `/data/ply/${plyName}.ply`;
                const asset = new pc.Asset(plyName, 'gsplat', { url: url });
                
                await new Promise((resolve, reject) => {
                    asset.on('load', resolve);
                    asset.on('error', reject);
                    app.assets.add(asset);
                    app.assets.load(asset);
                });
                
                // æ›´æ–°åŠ è½½æç¤º
                if (loadingEl) {
                    loadingEl.innerHTML = `
                        <div class="loading-spinner"></div>
                        <div class="loading-text">æ¸²æŸ“3Dæ¨¡å‹...</div>
                    `;
                }
                
                // åˆ›å»ºé«˜æ–¯æ³¼æº…å®ä½“
                const splatEntity = new pc.Entity('gsplat');
                splatEntity.addComponent('gsplat', { asset: asset });
                splatEntity.setLocalEulerAngles(180, 0, 0); // é»˜è®¤ç¿»è½¬
                app.root.addChild(splatEntity);
                
                // æ¨¡å‹æ§åˆ¶å˜é‡
                let modelPosition = { x: 0, y: 0, z: 0 };
                let targetModelPosition = { x: 0, y: 0, z: 0 };
                let modelRotation = { x: 180, y: 0, z: 0 };
                let targetModelRotation = { x: 180, y: 0, z: 0 };
                let initialGyro = null;
                let scrollYOffset = 0;
                
                const config = {
                    parallaxIntensity: 0.3,
                    gyroEnabled: true
                };
                
                // æ›´æ–°å¾ªç¯
                app.on('update', (dt) => {
                    const smoothFactor = 0.1;
                    
                    modelPosition.x += (targetModelPosition.x - modelPosition.x) * smoothFactor;
                    const finalTargetY = targetModelPosition.y + scrollYOffset;
                    modelPosition.y += (finalTargetY - modelPosition.y) * smoothFactor;
                    modelPosition.z += (targetModelPosition.z - modelPosition.z) * smoothFactor;
                    
                    modelRotation.x += (targetModelRotation.x - modelRotation.x) * smoothFactor;
                    modelRotation.y += (targetModelRotation.y - modelRotation.y) * smoothFactor;
                    modelRotation.z += (targetModelRotation.z - modelRotation.z) * smoothFactor;
                    
                    splatEntity.setLocalPosition(modelPosition.x, modelPosition.y, modelPosition.z);
                    splatEntity.setLocalEulerAngles(modelRotation.x, modelRotation.y, modelRotation.z);
                });
                
                // ease-outè¡°å‡æ›²çº¿
                function easeOutCubic(value, threshold, max) {
                    const absValue = Math.abs(value);
                    if (absValue <= threshold) return value;
                    const sign = value >= 0 ? 1 : -1;
                    const normalized = (absValue - threshold) / (max - threshold);
                    const damped = threshold + (max - threshold) * (1 - Math.pow(1 - normalized, 3));
                    return sign * Math.min(damped, max);
                }
                
                // é¼ æ ‡æ§åˆ¶
                let isDragging = false;
                let lastX = 0, lastY = 0;
                
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => isDragging = false);
                canvas.addEventListener('mouseleave', () => isDragging = false);
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) {
                        const rect = canvas.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const normalizedX = (e.clientX - centerX) / (rect.width / 2);
                        const normalizedY = (e.clientY - centerY) / (rect.height / 2);
                        
                        const simulatedGamma = normalizedX * 35;
                        const simulatedBeta = normalizedY * 25;
                        const dampenedBeta = easeOutCubic(simulatedBeta, 15, 25) * 0.5;
                        const dampenedGamma = easeOutCubic(simulatedGamma, 20, 35);
                        
                        targetModelRotation.x = 180 + dampenedBeta * config.parallaxIntensity;
                        targetModelRotation.y = -dampenedGamma * config.parallaxIntensity;
                        
                        const positionIntensity = 0.008;
                        targetModelPosition.x = -dampenedGamma * positionIntensity;
                        targetModelPosition.y = dampenedBeta * positionIntensity * 0.5;
                    } else {
                        const deltaX = e.clientX - lastX;
                        const deltaY = e.clientY - lastY;
                        targetModelRotation.y += deltaX * 0.5;
                        targetModelRotation.x += deltaY * 0.5;
                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });
                
                // é™€èºä»ªæ§åˆ¶
                if (window.DeviceOrientationEvent) {
                    const handleOrientation = (e) => {
                        if (!config.gyroEnabled || e.beta === null || e.gamma === null) return;
                        
                        if (!initialGyro) {
                            initialGyro = { beta: e.beta, gamma: e.gamma };
                            return;
                        }
                        
                        const deltaBeta = e.beta - initialGyro.beta;
                        const deltaGamma = e.gamma - initialGyro.gamma;
                        
                        const dampenedBeta = easeOutCubic(deltaBeta, 15, 25) * 0.5;
                        const dampenedGamma = easeOutCubic(deltaGamma, 20, 35);
                        
                        targetModelRotation.x = 180 + dampenedBeta * config.parallaxIntensity;
                        targetModelRotation.y = -dampenedGamma * config.parallaxIntensity;
                        
                        const positionIntensity = 0.008;
                        targetModelPosition.x = -dampenedGamma * positionIntensity;
                        targetModelPosition.y = dampenedBeta * positionIntensity * 0.5;
                    };
                    
                    // æ·»åŠ é™€èºä»ªç›‘å¬å™¨
                    if (!gyroListenerAdded) {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        gyroListenerAdded = true;
                        console.log('âœ… é™€èºä»ªäº‹ä»¶ç›‘å¬å·²æ·»åŠ ');
                    }
                }
                
                // æ»šåŠ¨è§†å·® - ç›‘å¬iframeå†…éƒ¨æ»šåŠ¨
                function getElementViewportPosition(element) {
                    const rect = element.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    const elementCenter = rect.top + rect.height / 2;
                    const viewportCenter = viewportHeight / 2;
                    const normalizedPosition = (elementCenter - viewportCenter) / (viewportHeight / 2);
                    return Math.max(-1, Math.min(1, normalizedPosition));
                }
                
                function easeOutCubicPosition(value, threshold, max) {
                    const absValue = Math.abs(value);
                    if (absValue <= threshold) return value;
                    const sign = value >= 0 ? 1 : -1;
                    const normalized = (absValue - threshold) / (max - threshold);
                    const damped = threshold + (max - threshold) * (1 - Math.pow(1 - normalized, 3));
                    return sign * Math.min(damped, max);
                }
                
                let initialScrollOffset = null;
                
                function updateScrollParallax() {
                    const position = getElementViewportPosition(container);
                    if (initialScrollOffset === null) {
                        initialScrollOffset = position;
                    }
                    const rawOffset = position - initialScrollOffset;
                    const dampenedOffset = easeOutCubicPosition(rawOffset, 0.6, 1.0);
                    const maxYOffset = 0.5 * 0.6;
                    scrollYOffset = -dampenedOffset * maxYOffset;
                }
                
                // ç›‘å¬iframeå†…éƒ¨æ»šåŠ¨
                try {
                    const iframeWin = document.getElementById('articleFrame').contentWindow;
                    if (iframeWin) {
                        iframeWin.addEventListener('scroll', updateScrollParallax, { passive: true });
                    }
                } catch (e) {
                    // å¿½ç•¥è·¨åŸŸé”™è¯¯
                }
                window.addEventListener('scroll', updateScrollParallax, { passive: true });
                updateScrollParallax();
                
                // é™€èºä»ªæ§åˆ¶ï¼ˆå¤åˆ»gsplat-viewer2.htmlï¼‰
                if (gyroPermissionGranted && !gyroListenerAdded) {
                    window.addEventListener('deviceorientation', (event) => {
                        if (!config.gyroEnabled) return;
                        
                        if (!initialGyro) {
                            initialGyro = { beta: event.beta || 0, gamma: event.gamma || 0 };
                        }
                        
                        const deltaX = (event.gamma || 0) - initialGyro.gamma;
                        const deltaY = (event.beta || 0) - initialGyro.beta;
                        
                        const maxRotation = 15;
                        const dampedX = easeOutCubic(deltaX, 10, 30);
                        const dampedY = easeOutCubic(deltaY, 10, 30);
                        
                        targetModelRotation.y = pc.math.clamp(-dampedX * 1.5, -maxRotation, maxRotation);
                        targetModelRotation.x = 180 + pc.math.clamp(dampedY * 1.5, -maxRotation, maxRotation);
                    });
                    gyroListenerAdded = true;
                }
                
                // æˆåŠŸ! éšè—åŠ è½½æç¤º
                if (loadingEl) loadingEl.style.display = 'none';
                console.log('âœ“ 3Dæ¨¡å‹åŠ è½½æˆåŠŸ:', plyName);
                
                return true;
                
            } catch (error) {
                console.error('âœ— 3Dæ¨¡å‹åŠ è½½å¤±è´¥:', plyName, error);
                if (loadingEl) loadingEl.textContent = 'åŠ è½½å¤±è´¥';
                return false;
            }
        }
        
        // æ–‡ç« IDåˆ°mirrorsç›®å½•çš„æ˜ å°„
        const articleMap = {
            1: '01',   // è…¾è®¯æ–°é—»
            2: '02',   // æ·±åº¦ä¸¨ä¸‰èˆªæ¯æ—¶ä»£
            3: '03',   // æ·±åœ³é’å¹´ä½æˆ¿
            4: '04',   // æµ·å—è‡ªè´¸æ¸¯
            5: '05',   // å¤–äº¤éƒ¨äºšæ´²ç‰¹ä½¿
            6: '06',   // å…ƒæ—¦ç«è½¦ç¥¨
            7: '07',   // å’æ˜¥èˆå‰§
            8: '08',   // é£Ÿç‰©é“¶è¡Œ
            9: '12',   // æœŸå¾…ï¼æ·±åœ³å¥‡è¿¹
            10: '09',  // ä¸­å¤®è´¢åŠ
            11: '10',  // å±±ä¸œèˆ°å…¥åˆ—6å‘¨å¹´
            12: '11'   // å°å½“å±€å°çº¢ä¹¦
        };
        
        // è·å–å½“å‰æ–‡ç« ID
        const urlParams = new URLSearchParams(window.location.search);
        const articleId = urlParams.get('id') || '1';
        const mirrorDir = articleMap[articleId] || '01';
        
        console.log(`ğŸ“– åŠ è½½æ–‡ç« ID: ${articleId} -> mirrors/${mirrorDir}`);
        
        // è·å–iframeå…ƒç´ 
        const iframe = document.getElementById('articleFrame');
        
        if (!iframe) {
            console.error('âŒ æ‰¾ä¸åˆ°iframeå…ƒç´ ');
        }
        
        // å…ˆè®¾ç½®loadäº‹ä»¶ç›‘å¬å™¨
        iframe.addEventListener('load', async () => {
            console.log('ğŸ“„ IframeåŠ è½½å®Œæˆ');
            
            // æ˜¾ç¤ºé™€èºä»ªæƒé™è¯·æ±‚å¼¹çª—ï¼ˆiOSè®¾å¤‡ï¼‰
            if ('ontouchstart' in window) {
                showGyroPermissionModal();
            }
            
            // ç­‰å¾…iframeå®Œå…¨æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                if (!iframeDoc) {
                    console.error('âŒ æ— æ³•è®¿é—®iframeå†…å®¹ï¼ˆå¯èƒ½æ˜¯è·¨åŸŸé—®é¢˜ï¼‰');
                    return;
                }
                
                console.log('ğŸ” iframe src:', iframe.src);
                console.log('ğŸ” iframe contentWindow.location:', iframe.contentWindow.location.href);
                console.log('ğŸ” iframe DOM ready state:', iframeDoc.readyState);
                console.log('ğŸ” iframe body:', iframeDoc.body ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
                console.log('ğŸ” iframe HTML length:', iframeDoc.documentElement.outerHTML.length);
                
                // è¾“å‡ºHTMLçš„å‰1000ä¸ªå­—ç¬¦ç”¨äºè°ƒè¯•
                const htmlPreview = iframeDoc.documentElement.outerHTML.substring(0, 1000);
                console.log('ğŸ” iframe HTML preview (å‰1000å­—ç¬¦):\n', htmlPreview);
                
                // å…ˆæŸ¥æ‰¾æ‰€æœ‰div
                const allDivs = iframeDoc.querySelectorAll('div');
                console.log('ğŸ” æ‰€æœ‰divæ•°é‡:', allDivs.length);
                
                // æŸ¥æ‰¾å¸¦classçš„div
                const divsWithClass = iframeDoc.querySelectorAll('div[class]');
                console.log('ğŸ” å¸¦classçš„divæ•°é‡:', divsWithClass.length);
                
                // æŸ¥æ‰¾æ‰€æœ‰å¸¦data-plyçš„å…ƒç´ 
                const allDataPly = iframeDoc.querySelectorAll('[data-ply]');
                console.log('ğŸ” å¸¦data-plyçš„å…ƒç´ :', allDataPly.length);
                
                // ç›´æ¥æœç´¢HTMLä¸­æ˜¯å¦åŒ…å«splat-container
                const htmlContent = iframeDoc.documentElement.outerHTML;
                const hasSplatContainer = htmlContent.includes('splat-container');
                console.log('ğŸ” HTMLä¸­åŒ…å«splat-container:', hasSplatContainer);
                
                if (hasSplatContainer) {
                    console.log('ğŸ” å°è¯•ç”¨ä¸åŒé€‰æ‹©å™¨æŸ¥æ‰¾...');
                    const test1 = iframeDoc.querySelector('.splat-container');
                    const test2 = iframeDoc.querySelector('div.splat-container');
                    const test3 = iframeDoc.querySelectorAll('.splat-container');
                    console.log('querySelector(.splat-container):', test1);
                    console.log('querySelector(div.splat-container):', test2);
                    console.log('querySelectorAll(.splat-container):', test3);
                }
                
                // æŸ¥æ‰¾æ‰€æœ‰å¸¦ data-ply å±æ€§çš„å®¹å™¨
                const gsplatContainers = iframeDoc.querySelectorAll('.splat-container[data-ply]');
                
                console.log('ğŸ” querySelectorAllç»“æœ:', gsplatContainers);
                console.log('ğŸ” æ‰¾åˆ°çš„å®¹å™¨æ•°é‡:', gsplatContainers.length);
                
                if (gsplatContainers.length === 0) {
                    console.log('â„¹ï¸ å½“å‰æ–‡ç« æ²¡æœ‰3Dæ¨¡å‹');
                    return;
                }
                
                console.log(`ğŸ¯ æ‰¾åˆ° ${gsplatContainers.length} ä¸ª3Dæ¨¡å‹å®¹å™¨`);
                
                // ä½¿ç”¨ Intersection Observer å®ç°å»¶è¿ŸåŠ è½½ï¼Œå‡å°‘å†…å­˜å‹åŠ›
                const loadedModels = new Set();
                
                const observerOptions = {
                    root: null,
                    rootMargin: '300px',  // æå‰300pxå¼€å§‹åŠ è½½
                    threshold: 0.01
                };
                
                const modelObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const container = entry.target;
                            const plyName = container.getAttribute('data-ply');
                            
                            if (!loadedModels.has(plyName)) {
                                loadedModels.add(plyName);
                                const index = Array.from(gsplatContainers).indexOf(container);
                                console.log(`ğŸ‘ï¸ [${index + 1}/${gsplatContainers.length}] æ¨¡å‹è¿›å…¥è§†å£,å¼€å§‹åŠ è½½: ${plyName}`);
                                
                                createGSplatViewer(container, plyName).catch(err => {
                                    console.error(`âŒ æ¨¡å‹åŠ è½½å¤±è´¥ [${plyName}]:`, err);
                                    loadedModels.delete(plyName);  // å¤±è´¥åå…è®¸é‡è¯•
                                });
                                
                                // åŠ è½½ååœæ­¢è§‚å¯Ÿæ­¤å®¹å™¨
                                modelObserver.unobserve(container);
                            }
                        }
                    });
                }, observerOptions);
                
                // è§‚å¯Ÿæ‰€æœ‰å®¹å™¨
                gsplatContainers.forEach((container) => {
                    modelObserver.observe(container);
                });
                
            } catch (error) {
                console.error('âŒ iframeåˆå§‹åŒ–é”™è¯¯:', error);
            }
        });
        
        // æœ€ååŠ è½½iframeå†…å®¹ - æ·»åŠ æ—¶é—´æˆ³ç»•è¿‡Safariç¼“å­˜
        iframe.src = '/mirrors/' + mirrorDir + '/index.html?t=' + Date.now();
    </script>
</body>
</html>
